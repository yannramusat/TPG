#!/bin/env python3

from app import App

if __name__ == "__main__":
    # app setup
    scheme = "bolt"
    hostname = "localhost"
    port = "7687"
    uri = f"{scheme}://{hostname}:{port}"
    app = App(uri, "neo4j", verbose=False)

    # common prefix for CSVs; the data has been generated by iBench
    prefix = "file:///home/yann/research/ibench/build/ibench/"
    nbLaunches = 1
    showStats = True
    nodeIndexes = True
    relIndexes = True
    x = [100, 200, 500, 1_000, 2_000] #, 5_000, 10_000, 20_000, 50_000, 100_000]

    # execute the alternative implementation of the scenario PersonAddress with Separate indexes
    from scenarios.personaddress import PersonAddressScenarioSeparateIndexes
    results_Sep_NI_RI = []
    for i in x:
        scenario = PersonAddressScenarioSeparateIndexes(prefix, size=i)
        results_Sep_NI_RI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=True, relIndex=True))
    
    results_Sep_NI = []
    for i in x:
        scenario = PersonAddressScenarioSeparateIndexes(prefix, size=i)
        results_Sep_NI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=True, relIndex=False))
    
    results_Sep_RI = []
    for i in x:
        scenario = PersonAddressScenarioSeparateIndexes(prefix, size=i)
        results_Sep_RI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=False, relIndex=True))
    
    results_Sep = []
    for i in x:
        scenario = PersonAddressScenarioSeparateIndexes(prefix, size=i)
        results_Sep.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=False, relIndex=False))

    # execute the plain implementation of the scenario PersonAddress
    from scenarios.personaddress import PersonAddressScenarioPlain
    results_Plain_NI_RI = []
    for i in x:
        scenario = PersonAddressScenarioPlain(prefix, size=i)
        results_Plain_NI_RI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=True, relIndex=True))
    
    results_Plain_NI = []
    for i in x:
        scenario = PersonAddressScenarioPlain(prefix, size=i)
        results_Plain_NI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=True, relIndex=False))
    
    results_Plain_RI = []
    for i in x:
        scenario = PersonAddressScenarioPlain(prefix, size=i)
        results_Plain_RI.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=False, relIndex=True))
    
    results_Plain = []
    for i in x:
        scenario = PersonAddressScenarioPlain(prefix, size=i)
        results_Plain.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=False, relIndex=False))

    # execute the alternative implementation with Conflict Detection of the scenario PersonAddress
    #from scenarios.personaddress import PersonAddressScenarioWithConflictDetection
    #resultsCD = []
    #for i in x:
    #    scenario = PersonAddressScenarioWithConflictDetection(prefix, size=i)
    #    resultsCD.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=nodeIndexes, relIndex=relIndexes))

    # optional printing of the results in the console
    if showStats:
        print(results_Sep_NI_RI)
        print(results_Sep_NI)
        print(results_Sep_RI)
        print(results_Sep)
        print(results_Plain_NI_RI)
        print(results_Plain_NI)
        print(results_Plain_RI)
        print(results_Plain)

    # plot results using matplotlib
    import matplotlib.pyplot as plt
    import numpy as np

    fig, (ax1, ax3) = plt.subplots(1, 2, layout="constrained")
    
    ax1.plot(x, results_Sep_NI_RI, label="Indexes on Nodes and Relations")
    ax1.plot(x, results_Sep_NI, label="Indexes on Nodes only")
    ax1.plot(x, results_Sep_RI, label="Indexes on Relations only")
    ax1.plot(x, results_Sep, label="Without indexes")

    ax1.set_title("$\mathtt{Separate}$ alternative")
    ax1.set_xlabel("number of rows in each input relation")
    ax1.set_ylabel("time (ms)")
    ax1.set_yscale("log")
    ax1.legend()

    ax3.plot(x, results_Plain_NI_RI, label="Indexes on Nodes and Relations")
    ax3.plot(x, results_Plain_NI, label="Indexes on Nodes only")
    ax3.plot(x, results_Plain_RI, label="Indexes on Relations only") 
    ax3.plot(x, results_Plain, label="Without indexes")

    ax3.set_title("$\mathtt{Plain}$ alternative")
    ax3.set_xlabel("number of rows in each input relation")
    ax3.set_ylabel("time (ms)")
    ax3.set_yscale("log")
    ax3.legend()

    fig.suptitle("$\mathsf{PersonAddress}$ scenario", fontsize=16)
    plt.show()
 
    # TEMPORARY BREAK POINT
    exit()

    # execute the Optimized alternative implementation of the scenario FlightHotel
    from scenarios.flighthotel import FlightHotelScenarioSeparateIndexes
    resultsOptiFH = []
    for i in x:
        scenario = FlightHotelScenarioSeparateIndexes(prefix, size=i)
        resultsOptiFH.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=True, relIndex=True))

    # execute the Optimized alternative implementation of the scenario FlightHotel (without Indexes!)
    resultsNoIndexFH = []
    for i in x:
        scenario = FlightHotelScenarioSeparateIndexes(prefix, size=i)
        resultsNoIndexFH.append(scenario.run(app, launches=nbLaunches, stats=showStats, nodeIndex=False, relIndex=False))

    # optional printing of the results in the console
    if showStats:
        print(resultsOptiFH)
        print(resultsNoIndexFH)
   
    #####
    # TEMPORARY PLOTTING
    import matplotlib.pyplot as plt
    import numpy as np

    fig, ax = plt.subplots(layout="constrained")
    ax.plot(x, resultsOptiFH, label="Optimized")
    ax.plot(x, resultsNoIndexFH, label="Without indexes")
    ax.set_title("$\mathtt{FlightHotel}$ scenario")
    ax.set_xlabel("cardinality of input relations")
    ax.set_ylabel("time [ms]")
    ax.set_yscale("log")
    ax.legend()
    plt.show()
    #####

    # close connection
    app.close()
